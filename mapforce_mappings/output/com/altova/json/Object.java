////////////////////////////////////////////////////////////////////////
//
// Object.java
//
// This file was generated by MapForce MapForce 2021r2sp1.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the MapForce Documentation for further details.
// http://www.altova.com/mapforce
//
////////////////////////////////////////////////////////////////////////

package com.altova.json;

import java.util.*;
import java.util.regex.Pattern;
import com.altova.json.PropertyGroup.PropertyGroupBehavior;

public class Object extends Value {
	Member[] members;
	
	public Object(Member[] members) {
		this.members = members;
	}
		
	public Type getType() { return Type.Object; }

	public Member[] getMembers() {
		return members;
	}

	protected void ApplyDescendants(HashMap<Value, ValidationInfo> itemInfos) {
		for (Member m: members) {
			m.getValue().Apply(itemInfos);
		}
	}

	protected ValidationInfo DoValidateCore(Validator validator, ValueAcceptor schema, HashMap<Value, ValidationInfo> itemInfos) {
		if (schema.getObject() != null) {
			int pc = getMembers().length;
			if (schema.getObject().getMaxProperties() != null) {
				if (pc > schema.getObject().getMaxProperties())
					return new ValidationInfo(Validity.Invalid);
			}
			if (schema.getObject().getMinProperties() != null) {
				if (pc < schema.getObject().getMinProperties())
					return new ValidationInfo(Validity.Invalid);
			}

			boolean[] propertiesRemoved = new boolean[pc];

			ValidationInfo res = new ValidationInfo(schema.getId());

			for (PropertyGroup group: schema.getObject().getGroups()) {
				boolean[] removeAfterGroup = new boolean[pc];

				for (PropertyRule rule: group.getRules()) {
					boolean failedAny = false;
					boolean matchedAny = false;
					boolean touched[] = new boolean[pc];

					for (int n = 0; n != pc; ++n) {
						if (propertiesRemoved[n])
							continue;
						switch (rule.getMatchKind()) {
							case Exact:
								if (!getMembers()[n].getName().equals(rule.getNameMatch()))
									continue;
								break;
							case Pattern:
								if (!Pattern.matches(rule.getNameMatch(), getMembers()[n].getName()))//? RegexOptions.ECMAScript
									continue;
								break;
							case All:
								break;
						}
						matchedAny = true;
						touched[n] = true;
						ValidationInfo itemRes = getMembers()[n].getValue().DoValidate(validator, rule.getValueAcceptor(), itemInfos);
						if (!itemRes.IsValid())
							failedAny = true;
						Merge(itemInfos, getMembers()[n].getValue(), itemRes);
					}

					if (matchedAny) {
						if (rule.getPresentAcceptor() != null) {
							ValidationInfo t = DoValidate(validator, rule.getPresentAcceptor(), itemInfos);
							if (!t.IsValid())
								failedAny = true;
							res.Merge(t);
						}
						switch (failedAny ? group.getMatchFailure() : group.getMatchSuccess()) {
							case Succeed:
								for (int i = 0; i != pc; ++i)
									removeAfterGroup[i] |= touched[i];
								break;
							case Fail:
								return new ValidationInfo(Validity.Invalid);
							case ContinueWithNext:
								break;
						}
					} else {
						if (rule.getAbsentAcceptor() != null) {
							ValidationInfo t = DoValidate(validator, rule.getAbsentAcceptor(), itemInfos);
							if (!t.IsValid())
								return new ValidationInfo(Validity.Invalid);
							res.Merge(t);
						}
					}
				}

				for (int n = 0; n != pc; ++n)
					propertiesRemoved[n] |= removeAfterGroup[n];

				boolean allPropertiesRemoved = true;
				for (boolean b: propertiesRemoved)
					allPropertiesRemoved &= b;

				if (group.getNonMatch() == PropertyGroupBehavior.Succeed) {
					if (allPropertiesRemoved)
						break;
				} else if (group.getNonMatch() == PropertyGroupBehavior.Fail) {
					if (!allPropertiesRemoved)
						break;
					return new ValidationInfo(Validity.Invalid);
				}
			}

			return res;
			//return new ValidationInfo(schema.Id);
		}

		return new ValidationInfo(Validity.Invalid);
	}
	private Comparator<Member> memberNameComparator = new Comparator<Member>() { public int compare(Member m1, Member m2) { return m1.getName().compareTo(m2.getName()); } };

	protected int GetHashCode() {
		ArrayList<Member> ma = new ArrayList<Member>(Arrays.asList(getMembers()));
		Collections.sort(ma, memberNameComparator);
		
		MakeUnique(ma);
		int n = 961761211;
		for (Member m: ma) {
			n ^= m.getName().hashCode() ^ m.getValue().GetHashCode();
		}
		return n;
	}

	static void MakeUnique(ArrayList<Member> members) {
		int t = 0;
		for (int s = 1; s != members.size(); ++s) {
			if (members.get(s).getName().equals(members.get(t).getName()))
				members.set(t, members.get(s) ); // replace it, last one wins
			else
				members.set(++t, members.get(s));
		}
		while (members.size() > t+1)
			members.remove(members.size() - 1);
	}

	protected boolean Equals(java.lang.Object obj) {
		Object o = obj instanceof Object ? (Object)obj : null;
		if (o == null)
			return false;

		ArrayList<Member> ma = new ArrayList<Member>(Arrays.asList(getMembers()));
		ArrayList<Member> mb = new ArrayList<Member>(Arrays.asList(o.getMembers()));
		Collections.sort(ma, memberNameComparator);
		Collections.sort(mb, memberNameComparator);
		MakeUnique(ma);
		MakeUnique(mb);
		if (ma.size() != mb.size())
			return false;
		for (int n = 0; n != ma.size(); ++n) {
			if (!ma.get(n).getName().equals(mb.get(n).getName()))
				return false;
			if (!ma.get(n).getValue().Equals(mb.get(n).getValue()))
				return false;
		}
		return true;
	}
}
