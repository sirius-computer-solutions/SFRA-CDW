////////////////////////////////////////////////////////////////////////
//
// Value.java
//
// This file was generated by MapForce MapForce 2021r2sp1.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the MapForce Documentation for further details.
// http://www.altova.com/mapforce
//
////////////////////////////////////////////////////////////////////////

package com.altova.json;

import com.altova.mapforce.IEnumerable;
import com.altova.mapforce.MFEmptySequence;

import java.util.HashMap;
import java.util.Map;

public abstract class Value extends java.lang.Object implements com.altova.mapforce.IMFNode {

	public enum Type {
		Null,
		String,
		Number,
		Boolean,
		Array,
		Object
	}
	
	public boolean IsA(String schema) {
		return _info != null ? _info.IsA(schema) : false;
	}

	public abstract Type getType();

	public String getLocalName() {
		assert false : "Method is not implemented.";
		return "";
	}

	public String getNamespaceURI() {
		assert false : "Method is not implemented.";
		return "";
	}

	public int /*altova.mapforce.MFNodeKind*/ getNodeKind() {
		assert false : "Method is not implemented.";
		return -1;
	}

	public String getNodeName() {
		assert false : "Method is not implemented.";
		return "";
	}

	public javax.xml.namespace.QName getQName() {
		assert false : "Method is not implemented.";
		return null;
	}

	public String getPrefix() {
		assert false : "Method is not implemented.";
		return "";
	}
	
	public String value() throws Exception {
		assert false : "Method is not implemented.";
		return "";
	}

	public java.lang.Object typedValue() throws Exception {
		throw new UnsupportedOperationException("Method is not implemented.");
	}

	public javax.xml.namespace.QName qnameValue() {
		assert false : "Method is not implemented.";
		return null;
	}

	public IEnumerable select(int mfQueryKind, java.lang.Object query) {
		if (getType() == Type.Null)
			return new MFEmptySequence();
		else
			throw new UnsupportedOperationException("Method is not implemented.");
	}		

	ValidationInfo _info;

	protected abstract ValidationInfo DoValidateCore(Validator validator, ValueAcceptor schema, HashMap<Value, ValidationInfo> itemInfos);

	protected static void Merge(HashMap<Value, ValidationInfo> itemInfos, Value value, ValidationInfo info) {
		ValidationInfo vi = itemInfos.containsKey(value) ? itemInfos.get(value) : null;
		if (vi != null) {
			vi.Merge(info);
		} else
			itemInfos.put(value, info);
	}

	protected static void Merge(HashMap<Value, ValidationInfo> itemInfos, HashMap<Value, ValidationInfo> local) {
		for (Map.Entry<Value, ValidationInfo> item :local.entrySet()) {
			ValidationInfo e = itemInfos.containsKey(item.getKey()) ? itemInfos.get(item.getKey()) : null;
			if (e != null) {
				e.Merge(item.getValue());
			} else
				itemInfos.put(item.getKey(), item.getValue());
		}
	}

	protected ValidationInfo DoValidate(Validator validator, ValueAcceptor schema, HashMap<Value, ValidationInfo> itemInfos) {
		HashMap<Value, ValidationInfo> local = new HashMap<Value, ValidationInfo>();
		ValidationInfo res = DoValidateCore(validator, schema, local);
		if (!res.IsValid())
			return res;
			
		for (AlsoAcceptor also: schema.getAlso()) {
			ValidationInfo combined = null;
			int matches = 0;
			for (Reference acceptor: also.getAcceptors()) {
				ValidationInfo r = DoValidate(validator, acceptor, local);
				if (r.IsValid()) {
					if (combined != null) combined.Merge(r); else combined = r;
					matches += 1;
				}
			}
			if (also.getMinAccepting() != null && matches < also.getMinAccepting())
				return new ValidationInfo(Validity.Invalid);
			if (also.getMaxAccepting() != null && matches > also.getMaxAccepting())
				return new ValidationInfo(Validity.Invalid);
			if (combined != null)
				res.Merge(combined);
		}

		Merge(itemInfos, local);
		return res;
	}

	protected ValidationInfo DoValidate(Validator validator, Reference reference, HashMap<Value, ValidationInfo> itemInfos) {
		ValueAcceptor acceptor = validator._schemamap.containsKey(reference.getTarget()) ? validator._schemamap.get(reference.getTarget()) : null;
		if (acceptor != null)
			return DoValidate(validator, acceptor, itemInfos);
		return new ValidationInfo(Validity.Invalid);
	}

	public void Validate(ValueAcceptor[] schemas, boolean jsonLines) {
		Validator validator = new Validator(schemas);
		HashMap<Value, ValidationInfo> itemInfos = new HashMap<Value, ValidationInfo>();
		if (jsonLines) {
			if (this instanceof Array) {
				Array array = (Array)this;
				for (Value item: array.getItems())
					item.Validate(schemas, false);
			}
		} else {
			ValidationInfo r = DoValidate(validator, schemas[0], itemInfos);
			Merge(itemInfos, this, r);
			Apply(itemInfos);
		}
	}

	protected abstract void ApplyDescendants(HashMap<Value, ValidationInfo> itemInfos);

	protected void Apply(HashMap<Value, ValidationInfo> itemInfos) {
		_info = itemInfos.containsKey(this) ? itemInfos.get(this) : null;
		ApplyDescendants(itemInfos);
	}

	protected abstract int GetHashCode();
	protected abstract boolean Equals(java.lang.Object obj);
	
	static public class EqualityComparer {
		Value value;		
		EqualityComparer(Value v) { value = v; }
		
		public boolean equals(java.lang.Object obj) { return obj instanceof Value.EqualityComparer ? value.Equals(((Value.EqualityComparer)obj).value) : false; }
		public int hashCode() { return value.GetHashCode(); }
	}
}
